import numpy as np
import requests
import random
import time

# Manager URL
manager_url = 'http://localhost:6000'

# Task types that can be generated by the IoT device
task_types = ["image_processing", "data_analysis", "video_streaming"]

def generate_task():
    """Generate a random task for offloading."""
    task = {
        'task_type': random.choice(task_types),
        'task_size': random.randint(10, 100),  # Task size in MB
        'deadline': random.randint(5, 30)      # Deadline in seconds
    }
    return task

def calculate_network_delay(task_size):
    """Calculate network delay based on task size and bandwidth."""
    network_bandwidth = 100  # MB/s, assumed network bandwidth
    return task_size / network_bandwidth

def send_task_to_manager(task):
    """Send the task to the central manager."""
    try:
        # Calculate network delay before sending the task
        network_delay = calculate_network_delay(task['task_size'])
        response = requests.post(manager_url + '/offload_task', json=task)
        if response.status_code == 200:
            result = response.json()
            result['network_delay'] = network_delay  # Add network delay to result
            return result
        else:
            print(f"Failed to offload task: {response.status_code}")
            return None
    except Exception as e:
        print(f"Error communicating with manager: {e}")
        return None

def run():
    """Main loop to generate and send tasks to the manager with random intervals."""
    while True:
        task = generate_task()
        print(f"Generated task: {task}")

        # Send the task to the manager
        result = send_task_to_manager(task)
        if result:
            print(f"Task processed by fog node {result['fog_node_number']}: {result}")
        else:
            print("Task could not be processed.")

        # Wait for a random interval (using Poisson distribution)
        wait_time = np.random.poisson(lam=2)  # Mean task arrival rate is 5 seconds
        time.sleep(wait_time)

if __name__ == "__main__":
    run()
